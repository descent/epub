<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link rel="stylesheet" href="../styles/dotepub.css" type="text/css" />
  <title>Dotepub.com</title>
</head>

<body>
	<div class=""><p><span><strong>(感謝網友 Leo 投遞此文)</strong></span></p><p>謹以此文紀念偉大的計算機科學巨匠 Ken Thompson 和 Dennis Ritchie，並同時向其他所有為 Unix 發展做出貢獻的黑客致敬。</p><h4>歷史的塵埃</h4><p>Unix 作為一個舉世聞名的操作系統已有 40 餘年的歷史，圍繞著這個古老的操作系統的發展又衍生出了一系列外圍軟件生態群，其中一個非常重要的組件就是 shell。<strong>它是操作系統最外層的接口，負責直接面向用戶交互並提供內核服務，</strong>包括命令行接口 (CLI) 或圖形界面接口 (GUI) 兩種形式。以 CLI 為例，它提供一套命令規範，是一種解釋性語言，將用戶輸入經過解釋器 (interpreter) 輸出使其轉化成真正的系統調用，實現人機交互的功能。</p><p>和操作系統一樣，shell 也經歷了一個漫長的演變史。如今大部分資料講述最古老的 shell 都是從 1977 年的 Bourne Shell 說起的，它最初移植到 Unix V7 上，被追認整個 shell 家族成員的鼻祖，後來的種群都是從其身上分支出來的。</p>
        
<img src="../img/f0.jpg" width="500"/>
        <p>對於 1977 年之前的歷史很多資料大多一筆帶過或略過不提。事實上，第一個移植到 Unix 上的 shell 卻不是 Steve Bourne 寫的，早在 1975 年 5 月，貝爾實驗室就對外發佈了第一個廣泛傳播的 Unix 版本——Unix V6（之前開發的版本只供內部研究之用），其根目錄下的 /bin/sh 是第一個 Unix 自帶的 shell，由 Ken Thompson 寫的，因此也被稱為 Thompson Shell。甚至，更早可以追溯到 1971 年的時候，Thompson Shell 就作為一個獨立於內核的應用程序而實現了，只不過從 1975 年正式問世到 1977 年被取代，短短兩年的壽命使得它很少為大多數人所認識。</p><p>關於 Thompson Shell 被取代的原因在後文中會給出說明，這裡著重介紹一下該 shell 本身的一些技術細節。坦白講，關於 Thompson Shell 的資料有點稀缺，但至少還能從網上找到源代碼和在線文檔。Thompson Shell 本身是由一個不足 900 行代碼的解釋器和一些外部命令工具組件 (utilities) 構成，用 K&amp;R C 寫成，下面給出各個組件的相關源碼和文檔鏈接。</p><ul> <li><strong>解釋器 sh</strong>：解析各種 shell 命令，包括內置命令和外部命令；源碼 sh.c；安裝路徑 /bin/sh；手冊 sh(1)。</li> </ul> <ul> <li><strong>內置命令</strong>手冊包括 chdir(1)，login(1)，newgrp(1)，shift(1)，wait(1)。</li> </ul><p>下面是外部命令：</p><ul> <li><strong>exit 命令</strong>：退出一個文件；源碼 exit.c；安裝路徑 /bin/exit；手冊 exit(1)。</li> </ul> <ul> <li><strong>goto 命令</strong>：在一個文件內跳轉 shell 控制流程；源碼 goto.c；安裝路徑 /bin/goto；手冊 goto(1)。</li> </ul> <ul> <li><strong>if 命令</strong>：條件判斷表達式，是 test 命令的前身；源碼 if.c；安裝路徑 /bin/if), 手冊 if(1)。</li> </ul> <ul> <li><strong>glob 命令</strong>：擴展命令參數通配符；源碼 glob.c；安裝路徑 /etc/glob；手冊 glob(8)。</li> </ul> <h4>命令結構和規範</h4><p>儘管後來遭「埋汰」，Thompson Shell 仍有著不容否認的歷史地位，其最大的價值在於<strong>它奠定了 shell 命令語言結構和規範的基礎，而且其解釋器具有跨平台的可移植性，並影響到了後來包括 Bourne Shell 在內的各種腳本語言設計實現。</strong>下面我們就以其中 5 個特性重溫一些大家已經耳熟能詳的命令規範，你也可以通過 sh(1) 手冊查看原始資料。</p><ul> <li><strong>過濾器 / 管道線 (filter/pipeline)。</strong>這絕對是要載入 Unix 史冊的發明，創立者是 Douglas McIlroy，Thompson Shell 引入並實現了這個偉大的概念——一個或多個命令組成一根過濾器的鏈條，由』|'或』^'符號分隔。除最後一個命令之外，每個命令的標準輸出都被作為下一個命令的標準輸入。這樣每個命令都作為一個獨立的進程來運行，並通過管道與鄰近的進程相連接。圓括弧內的命令序列整體上可以替代單個命令作為過濾器實現，比如用戶可以輸入」(A;B)|C」。</li> </ul> <ul> <li><strong>命令序列和後台進程。</strong>分號』;'指示多個命令序列化執行。』&amp;』符號指示該命令在後台異步執行，使得前面的管道線不必等待其終止，僅僅報告一個進程 id，這樣用戶以後可以通過 kill 命令與它通信。有益於進程管理。</li> </ul> <ul> <li><strong>I/O 重定向。</strong>它利用了 Unix 設計上的一個重要特性——<strong>一切皆文件</strong>，用三個符號表示：」重定向輸出，如果文件不存在則創建它，如果文件存在則截斷它；』&gt;&gt;』追加模式重定向輸出，如果文件不存在則創建它，如果文件存在則追加輸出至末尾處。</li> </ul> <ul> <li><strong>通配符擴展 (globbing)。</strong>通配符的概念源自於正則表達式，使得解釋器智能地處理用戶不完全輸入，比如記不清文件名、一次性輸入多個文件等。』?'匹配任意單一字符；』*'匹配任意字符串（包括空串）；成對』['和']『定義了字符集合一個類，可匹配方括號內任意成員，用』-'兩端可指定一系列連續字符匹配範圍。</li> </ul> <ul> <li><strong>參數傳遞。</strong>這裡主要引入了位置參數和選項參數的概念：』$n'指示 shell 調用的第 n 個參數替代；還定義了兩個選項參數』-t'和』-c'，前者用於交互，導致 shell 從標準輸入中讀入一行作為用戶執行的系統命令，後者指示 shell 將附帶的下一個參數作為命令執行（可正確處理換行符），是對』-t'的補充，特別是調用者已經讀取了命令其中某些字符的情況下。如果不帶選項參數則直接讀取文件名</li> </ul> <h4>解釋器的原理與實現</h4><p>接下來馬上要進入核心部分了，為了搞懂 shell 解釋器原理，我們要對其整個工作流程做個描述（這裡給出一份帶註解的 sh.c 源碼剖析）。讀過《編譯原理》的同學知道，解釋器的實現跟編譯器差不多，只不過省略了生成目標代碼這一步，直接將用戶輸入（shell 命令）轉化成輸出（系統調用）。<strong>軟件前端是一致的，包括預處理、詞法掃瞄、語法分析和語義分析，最後還要附加一個進程管理。</strong>當然相較於現代編譯器，Thompson Shell 解釋器在算法和規模上都要簡單得多，不過原理上是相通的，何況年代上要比 Lex &amp; Yacc 還要早。麻雀雖小，五臟俱全，對於初學者來說，從 Thompson Shell 去入手編譯原理或許不失為一種好選擇。</p><h4>預處理 (preprocessor)</h4><p>同 C 預處理器需要事先將源代碼中包含的宏和頭文件展開一樣，Thompson Shell 首先需要處理命令中的<strong>選項參數</strong>和<strong>位置參數</strong>。選項參數有兩種』-t'和』-c'，決定了 shell 從標準輸入還是參數緩存中讀取字符（見 sh(1)）。此外字符序列中還要處理<strong>反斜槓』\』</strong>，判斷是轉義字符還是行接續符，前者對下一個字符設置引用標識，表明做普通字符處理，後者將緊鄰其後換行符過濾掉。</p><p>位置參數是<strong>美元符號』$』</strong>打頭的，後帶一個數字，如』$n'，預處理器對 shell 命令參數從頭開始計數，返回數字 n 指定的參數位置。如果遇上 double'$$』，則表示當前的進程標識，調用 getpid() 獲取。</p><p>注意到預處理器需要一次讀取多個字符，這樣就會多讀一個不必要的字符。對此解釋器提供了一種<strong>預讀 (peek)</strong> 方式，即每次從輸入流讀取一個字符時，放入一個預讀緩存裡（只有一個 int 大小的堆棧），也叫<strong>回退 (push back)</strong>。此後先從預讀緩存中讀取，如果緩存被讀完，則從輸入流中讀取。</p><h4>詞法掃瞄 (lexical scanning)</h4><p>經過預處理後的字符序列將被切割成為一系列<strong>詞法記號 (token)</strong>，安置在 token 列表中，掃瞄器將對以下幾類字符做如下處理。</p><ul> <li><strong>空格和 tab</strong>：簡單過濾。</li> </ul> <ul> <li><strong>引號</strong>：需要成對出現，字符本身被過濾，一對引號之間所有字符都被設置引用標識，作為一個 token。</li> </ul> <ul> <li><strong>元字符</strong>：如』&amp;』，』|'等，字符本身作為一個單獨 token。</li> </ul> <ul> <li><strong>其他字符</strong>：一律填充 token，直到碰上以上字符分隔為止。</li> </ul><p>舉一個例子，當我們輸入命令」(ls; cat tail) &gt;junk」，那麼 token 列表映像將是這樣的：</p>


<img src="../img/f1.jpg" width="500"/>
        <h4>語法分析 (syntax parser)</h4><p>語法分析就是將 token 列表中的元素作為<strong>表達式 (expression)</strong> 並以節點為單位構建語法樹，簡單命令是一個表達式，而復合命令以及命令序列是多個表達式的組合。Thompson Shell 中以簡單數組作為語法樹的容器，實際上這是結構體的一種變形，只不過每個成員字段大小都一樣（都是 sizeof int）而已。一個語法樹節點最多有 6 個字段（大小根據類型可變），分別是</p><ul> <li><strong> DTYP（節點類型）</strong>：每個節點都有唯一的類型，又分為四種——TCOM（簡單命令）、TPAR（復合命令）、TFIL（過濾器 / 管道線）、TLST（命令序列）。</li> </ul> <ul> <li><strong>DLEF（左子樹節點）</strong>：相當於鏈表指針，根據 DTYP 定義有所不同。如過濾器類型左子樹節點為前一個命令的輸出重定向文件，右子樹節點為後一個命令的輸入重定向文件。</li> </ul> <ul> <li><strong>DRIG（右子樹節點）</strong>：同上。</li> </ul> <ul> <li><strong>DFLG（節點屬性）</strong>：這是個標誌位 (flag)，決定該節點包含命令的屬性以及以什麼樣的狀態執行。</li> </ul> <ul> <li><strong>DSPR（子命令）</strong>：兩重含義，對於簡單命令，該字段為空；對於復合命令，該字段指向子語法樹節點。</li> </ul> <ul> <li><strong>DCOM（命令字符）</strong>：引用命令字符序列。</li> </ul><p>語法樹節點生成順序根據 token 列表中每個元素的<strong>優先級 (priority)</strong> 而定，首先遍歷整個列表，找到優先級最高的 token 作為根節點，再分別生成左右子樹，這是一種最簡單的<strong>自頂向下 (top-down)</strong> 解決方案。各個 token 優先級視 DTYP 字段而定</p><table class="aligncenter" width="367" border="1" cellspacing="0" cellpadding="0"> <tbody> <tr> <td valign="top" width="91"> <p style="text-align: center">優先級</p></td> <td valign="top" width="180"> <p style="text-align: center"> Token</p></td> <td valign="top" width="96"> <p style="text-align: center">DTYP</p></td> </tr> <tr> <td valign="top" width="91"> <p style="text-align: center"> 第一級</p></td> <td valign="top" width="180"> <p style="text-align: center">『&amp;』 &nbsp;』;』 &nbsp;』\n'</p></td> <td valign="top" width="96"> <p style="text-align: center">TLST</p></td> </tr> <tr> <td valign="top" width="91"> <p style="text-align: center"> 第二級</p></td> <td valign="top" width="180"> <p style="text-align: center">『|』 &nbsp;』^』</p></td> <td valign="top" width="96"> <p style="text-align: center">TFIL</p></td> </tr> <tr> <td valign="top" width="91"> <p style="text-align: center"> 第三級</p></td> <td valign="top" width="180"> <p style="text-align: center">&nbsp;』(『 &nbsp;』)』</p></td> <td valign="top" width="96"> <p style="text-align: center">TPAR</p></td> </tr> <tr> <td valign="top" width="91"> <p style="text-align: center"> 第四級</p></td> <td valign="top" width="180"> <p style="text-align: center">其它字符</p></td> <td valign="top" width="96"> <p style="text-align: center"> TCOM</p></td> </tr> </tbody> </table><p>語法樹的構建過程中還使用了一種基於<strong>「有限狀態機 (finite-state machine)」</strong>的動態規划算法，其實現是將整個邏輯流程劃分為四個狀態：syntax、syn1、syn2、syn3，對應於上面 token 優先級，程序在每個狀態下都生成一個相應類型的節點，同時還生成四種策略，以決議下一步將轉移到何種狀態（根據優先級搜索對應的 token）。這個四種策略分別是</p><ul> <li><strong>生成左子樹</strong>：左邊 token 列表遞進到下層狀態。</li> </ul> <ul> <li><strong>生成右子樹</strong>：右邊 token 列表並回溯到上層狀態或遞歸調用。</li> </ul> <ul> <li><strong>找不到對應 token</strong>：保持原有 token 列表遞進到下層狀態。</li> </ul> <ul> <li><strong>生成節點</strong>：直接返回節點。</li> </ul><p>當我們遍歷完整個 token 列表後，程序總是能返回最初的調用點，即根節點上，從而生成一棵完整的語法樹。這種算法的好處是<strong>程序員不必關注具體實現的每個細枝末節，只要關注相應的狀態並制定對應的轉移策略即可。</strong>還值得一提的是每個轉移策略都是發生在賦值語句或返回語句上，並使用函數實參保存臨時變量，這樣就避免了調用次數過多導致堆棧溢出。</p><p>依舊舉兩個個例子，比如命令」A &amp; ; B | C」對應的語法樹</p>
        
<img src="../img/f2.jpg" width="500"/>
        <p>命令」(A ; B) | C」對應的語法樹：</p>

<img src="../img/f3.jpg" width="500"/>
        <h4>語義分析 (Semantic Analyzer)</h4><p>語法分析僅僅停留在 token 表達式合法性層面上，它並不知道該表達式是否有意義，比如哪些命令是要後台運行，哪些命令的 I/O 被重定向到管道線上，通配符該如何擴展等等，這時候要靠語義分析了。這裡的「語義」體現在對特殊字符的動態處理以及語法樹節點的字段設置，根據<strong>上下文 (context)</strong> 而定。比如對於元字符』&gt;』，我們要判斷輸出重定向到哪個文件，是截斷還是追加。對於通配符』?'、』*'和』[...]『，我們要決定對哪些字符進行擴展，這些在 /etc/glob 中專門處理。對於語法樹節點，除了自身固有屬性之外，還需要繼承上層節點的屬性，以及下推屬性到下層子樹節點，下面列了一張表格說明。</p><table border="1" cellspacing="0" cellpadding="0"> <tbody> <tr> <td valign="top" width="67"> <p style="text-align: center">DTYP</p></td> <td valign="top" width="217"> <p style="text-align: center">DLEF/DRIG</p></td> <td valign="top" width="227"> <p style="text-align: center">DFLG</p></td> <td valign="top" width="57"> <p style="text-align: center">DSPR</p></td> </tr> <tr> <td valign="top" width="67"> <p style="text-align: center">TLST</p></td> <td valign="top" width="217"> 可以為空，也可以是其它節點，類型可以是 TLST/TFIL/TCOM</td> <td valign="top" width="227"> 自身屬性為 0；如果帶』&amp;』，則下推屬性 FINT|FAND|FPRS 到左右子樹（忽略信號、後台異步，打印 pid）</td> <td valign="top" width="57">空</td> </tr> <tr> <td valign="top" width="67"> <p style="text-align: center"> TFIL</p></td> <td valign="top" width="217"> 必須同時存在、，類型只能是 TCOM 或 TPAR</td> <td valign="top" width="227"> 自身屬性繼承自上層 TLST；下推 FPIN 到左子樹節點；下推 FPOU 到右子樹節點。</td> <td valign="top" width="57">空</td> </tr> <tr> <td valign="top" width="67"> <p style="text-align: center"> TPAR</p></td> <td valign="top" width="217"> 空</td> <td rowspan="2" valign="top" width="227">繼承上層的 TLST 和 TFIL；如果是追加模式重定向輸出，加上 FCAT；如果是復合命令中最後一個子命令，加上 FPAR， 將不會 fork 子進程。</td> <td valign="top" width="57">子命令</td> </tr> <tr> <td valign="top" width="67"> <p style="text-align: center"> TCOM</p></td> <td valign="top" width="217"> 左子樹節點為輸入重定向文件，右子樹為節點輸出重定向文件。</td> <td valign="top" width="57">空</td> </tr> </tbody> </table> <h4>執行命令 (Executor)</h4><p>當前面一系列步驟之後，如果錯誤計數為 0，則解釋器從語法樹的根節點開始，<strong>深度優先遍歷</strong>所有節點，並根據前面語法和語義分析得到的類型和屬性，一一執行所包含的命令，以生成最後的系統調用。</p><p>對於<strong>命令序列 (TLST) 節點</strong>，從左至右順序執行子樹節點命令。</p><p>對於<strong>過濾器 (TFIL) 節點</strong>，創建管道文件句柄，作為左右子樹的重定向文件。</p><p>對於<strong>簡單命令 (TCOM) 和復合命令 (TPAR) 節點</strong>，首先篩選出系統內置命令 (built-in)，對於剩下的外部命令則 fork 一個子進程執行它。如果是復合命令中最後一個子命令，那麼仍在原來的進程上執行而不必創建新進程。可執行文件路徑按先後順序搜索：①本地路徑；②/bin；③/usr/bin。</p><p><strong>多進程環境下，特別要注意文件句柄管理</strong>。命令間共享標準輸入輸出設備之外，還會重定向到管道線，而父進程在 fork 之後子進程會獲取一份文件句柄拷貝，所以<span><strong>父進程必須在 fork 之後立即關閉閒置的管道線句柄（如果有的話）以免造成資源洩漏，子進程也將在重定向之後關閉管道線句柄。</strong></span></p><p>對於<strong>後台命令</strong>需要打印 pid，但不需要響應中斷信號，父進程也不必等待子進程終止。其餘進程命令執行中可捕獲中斷信號，並轉入相應的處理函數。</p><p>解釋器用內置的 errno 全局變量保存進程終止狀態，並生成<strong>終止報告 (termination report)</strong>，系統調用 wait() 用於返回終止進程的 pid 並輸出報告消息索引。</p><h4>孰優孰劣</h4><p>儘管 Thompson Shell 是一款優秀的命令解釋器，還產生了多項歷史創舉，但遺憾的是依然得不到命運女神的垂青，這要歸咎於其自身的缺陷——<strong>功能單一、命令分散、控制流過於簡單，尚無法用來編寫腳本 (script)</strong>。隨著 Unix 日益壯大，它已經無法應付趨於繁雜的編程項目了。那時還出現了一個叫 John Mashey 的人寫的 PWB Shell（又叫做 Mashey Shell），基於 Thompson Shell 做了些改進，擴展了命令集，增加了 shell 變量，還增加了 if-then-else-endif，for，while 等控制邏輯。不幸的是它比 Thompson Shell 更短命，因為 1977 年它遇上了一個強勁的對手。</p><p>沒錯，那就是 Bourne Shell，它的主要優點是真正實現了結構化腳本編程，比之前的 shell 實現得都要好，更要命的是它與前兩個 shell 都不兼容，於是一場標準化的論戰開始了。在 David G. Korn（ksh 作者）寫的「ksh – An Extensible High Level Language」一文中提及，Steve Bourne 和 John Mashey 在三次連續的 Unix 用戶組集會上爭論他們各自的理由。在這些集會之間，各自增進他們的 shell 來擁有對方的功能。還設立了一個委員會來選擇標準 shell，最終還是選擇了 Bourne shell 作為標準。</p><p>於是從 Unix V7 開始就有了前面所說的」Bourne Shell Family」。然而歷史上沒有完美的技術，隨著八、九十年代操作系統迅猛發展，針對 Bourne Shell 的詬病也越來越多了。在解釋器本身實現上，我看到網上一個對其評價是「universally considered to be one of the most horrible C code ever written」，至於原因去看一下 mac.h 就知道了，包括基本運算符、關鍵字在內的大量宏定義使得整個代碼看上去簡直不是 C 寫的，也許 Bourne 是想把解釋器打造成自己獨特的風格吧，也難怪後來的 bash 以<strong>「born again」</strong>命名就是對其祖先的戲謔性調侃。另外內存管理上的一些毛病帶來平台可移植性問題，至於其中的技術細節有點高級，超出本文範疇。</p><h4>Thompson Again Shell?</h4><p>雖然歷史沒有給 Thompson Shell 一個機會，但它並非就此同 Unix V6 那樣一同淪為開源博物館上的古老「化石」。作為出自頂級黑客之手的作品，作為伴隨 Unix 那樣偉大操作系統一同曾經流行計算機的產物，至今仍受國內外程序員的緬懷，或將其改寫，或為其作注。比如國外一個站點 v6shell.org 上就實現了一個免費開源的可移植性 shell，它兼容並擴充原來的 Thompson Shell 並且可用來做腳本編程。再比如中國程序員寒蟬退士在其個人博客上發佈了一個註解版，並對原版做了一些改寫，主要是將<strong> K&amp;R C</strong> 轉為<strong> ANSI C</strong>，並且符合<strong> POSIX 規範</strong>，使原本晦澀難懂的源碼變得清晰易讀起來。正是因為接觸到他的版本激起了我對老 Unix 的考古興趣，才有了這篇「考古筆記」。我在想不知今後會不會像 bash 那樣，出一個 tash 來呢？</p><h4>一些感想</h4><p>本來全文應該就此結束了，但此時此刻不禁想多說幾句。這篇筆記當初並非有意而為之，在 hacking 源碼的過程中感想積累多了也就逐漸成章了。看代碼、作註解、查資料、寫此文，前後歷經四個多禮拜，是在繁雜的工作中「擠乳溝」擠出來的零散時間片拼湊起來的，雖然文字不長但也算耗費了一番心血，酸甜苦辣心中自明，體會到踏上社會之後潛下心做研究之艱難。如今面對這樣一份不到 900 行寫成的，沒有一行多餘的代碼，<strong>簡潔 (clarity)、乾淨 (clean)、快速 (fast)，</strong>這就是 Pure C 的魅力，我深為這種厚重的編程功力所折服，正所謂<strong>「大道至簡」</strong>吧。雖然要完全弄懂它需要很多時間，但我相信這種代價卻是值得的。</p><p>最後再八卦一下，2011 年 Dennis Ritchie 去世了，有人生前問過他「學 C 需要多久才能成為熟練開發者並寫出重要產品代碼？」，Ritchie 回答「我不知道，我從沒去學過 C。」(I don't know. I never had to learn C.) 其實這裡已經給出了答案——<strong>那就是沒有比去閱讀 Unix 源代碼更好的選擇了，某種意義上 C 語言就是為 Unix 而生的。</strong></p>

<img src="../img/dennis_ritchie_by_juanosborne-d4dooi9.jpg" width="500"/>
        <h4>參考資料 </h4><p>The Unix Heritage Society：Unix 社區遺產，上面有 v6 和 v7 以及其它一些衍生版本的操作系統源代碼。</p><p>The Traditional Bourne Shell Family：Bourne Shell 家族簡史。</p><p>v6shell：osh，一個基於 Thompson Shell 的開源可移植性 old shell。</p><p>寒蟬退士的博客：Thompson Shell 的一個註解版。</p><p>Evolution of shells in Linux：簡述 Linux Shell 演變史。</p><p>附錄一個中文註釋的 shell 源碼</p><p>（全文完）</p></div>
</body>
</html>
