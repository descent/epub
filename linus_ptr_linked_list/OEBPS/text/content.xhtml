<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link rel="stylesheet" href="../styles/dotepub.css" type="text/css" />
  <title>Dotepub.com</title>
</head>

<body>
	<div class=""><p><strong>感謝網友 full_of_bull 投遞此文</strong>（註：此文最初發表在這個這裡，我對原文後半段修改了許多，並加入了插圖）</p>
        <p>Linus 大嬸在 slashdot 上回答一些編程愛好者的提問，其中一個人問他什麼樣的代碼是他所喜好的，大嬸表述了自己一些觀點之後，舉了一個指針的例子，解釋了什麼才是<strong> core low-level coding</strong>。</p>
        <p>下面是 Linus 的教學原文及翻譯——</p>
        <p>「At the opposite end of the spectrum, I actually wish more people understood the really core low-level kind of coding. Not big, complex stuff like the lockless name lookup, but simply good use of pointers-to-pointers etc. For example, I've seen too many people who delete a singly-linked list entry by keeping track of the 「prev」 entry, and then to delete the entry, doing something like。
</p>
<p>
        （在這段話的最後，我實際上希望更多的人瞭解什麼是真正的核心底層代碼。這並不像無鎖文件名查詢（註：可能是 git 源碼裡的設計）那樣龐大、複雜，只是僅僅像諸如使用二級指針那樣簡單的技術。例如，我見過很多人在刪除一個單項鏈表的時候，維護了一個」prev」表項指針，然後刪除當前表項，就像這樣）」</p>

        <div><div id="highlighter_376417" class="syntaxhighlighter cpp"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><p>1</p><p>2</p><p>3</p><p>4</p></td><td class="code"><div class="container">
        <p><code class="cpp keyword bold">if</code> <code class="cpp plain">(prev)</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">prev-&gt;next = entry-&gt;next;</code></p>
        <p><code class="cpp keyword bold">else</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">list_head = entry-&gt;next;</code></p>
        </div></td></tr></tbody></table></div></div><p>and whenever I see code like that, I just go 「This person doesn't understand pointers」. And it's sadly quite common.（當我看到這樣的代碼時，我就會想「這個人不瞭解指針」。令人難過的是這太常見了。）</p><p>People who understand pointers just use a 「pointer to the entry pointer」, and initialize that with the address of the list_head. And then as they traverse the list, they can remove the entry without using any conditionals, by just doing a 「*pp = entry-&gt;next」. （瞭解指針的人會使用鏈表頭的地址來初始化一個「指向節點指針的指針」。當遍歷鏈表的時候，可以不用任何條件判斷（註：指 prev 是否為鏈表頭）就能移除某個節點，只要寫)</p>
        
<pre>*pp = entry-&gt;next</pre>
        <p>So there's lots of pride in doing the small details right. It may not be big and important code, but I do like seeing code where people really thought about the details, and clearly also were thinking about the compiler being able to generate efficient code (rather than hoping that the compiler is so smart that it can make efficient code *despite* the state of the original source code). （糾正細節是令人自豪的事。也許這段代碼並非龐大和重要，<strong>但我喜歡看那些注重代碼細節的人寫的代碼，也就是清楚地瞭解如何才能編譯出有效代碼</strong>（而不是寄望於聰明的編譯器來產生有效代碼，即使是那些原始的彙編代碼））。</p><p>Linus 舉了一個單向鏈表的例子，但給出的代碼太短了，一般的人很難搞明白這兩個代碼後面的含義。正好，有個編程愛好者閱讀了這段話，並給出了一個比較完整的代碼。他的話我就不翻譯了，下面給出代碼說明。</p><p>如果我們需要寫一個 remove_if(link*, rm_cond_func*) 的函數，也就是傳入一個單向鏈表，和一個自定義的是否刪除的函數，然後返回處理後的鏈接。</p><p>這個代碼不難，基本上所有的教科書都會提供下面的代碼示例，而這種寫法也是大公司的面試題<strong>標準</strong>模板：</p>

        <div><div id="highlighter_237798" class="syntaxhighlighter cpp"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p></td><td class="code"><div class="container"><p><code class="cpp keyword bold">typedef</code> <code class="cpp keyword bold">struct</code> <code class="cpp plain">node</code></p><p><code class="cpp plain">{</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">struct</code> <code class="cpp plain">node * next;</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">....</code></p><p><code class="cpp plain">} node;</code></p><p><code class="cpp keyword bold">typedef</code> <code class="cpp color1 bold">bool</code> <code class="cpp plain">(* remove_fn)(node </code><code class="cpp keyword bold">const</code> <code class="cpp plain">* v);</code></p><p><code class="cpp plain">node * remove_if(node * head, remove_fn rm)</code></p><p><code class="cpp plain">{</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">for</code> <code class="cpp plain">(node * prev = NULL, * curr = head; curr != NULL; )</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">{</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">node * </code><code class="cpp keyword bold">const</code> <code class="cpp plain">next = curr-&gt;next;</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">if</code> <code class="cpp plain">(rm(curr))</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">{</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">if</code> <code class="cpp plain">(prev)</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">prev-&gt;next = next;</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">else</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">head = next;</code></p>
        <p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp functions bold">free</code><code class="cpp plain">(curr);</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">}</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">else</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">prev = curr;</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">curr = next;</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">}</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">return</code> <code class="cpp plain">head;</code></p><p><code class="cpp plain">}</code></p></div></td></tr></tbody></table></div></div><p>這裡 remove_fn 由調用查提供的一個是否刪除當前實體結點的函數指針，其會判斷刪除條件是否成立。這段代碼維護了兩個節點指針 prev 和 curr，<strong>標準的教科書寫法——刪除當前結點時，需要一個 previous 的指針，並且還要這裡還需要做一個邊界條件的判斷——curr 是否為鏈表頭</strong>。於是，要刪除一個節點（不是表頭），只要將前一個節點的 next 指向當前節點的 next 指向的對象，即下一個節點（即：prev-&gt;next = curr-&gt;next），然後釋放當前節點。</p><p>但在 Linus 看來，這是不懂指針的人的做法。那麼，什麼是 core low-level coding 呢？那就是<strong>有效地利用二級指針，將其作為管理和操作鏈表的首要選項。</strong>代碼如下：</p><div><div id="highlighter_22958" class="syntaxhighlighter cpp"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p></td><td class="code"><div class="container"><p><code class="cpp keyword bold">void</code> <code class="cpp plain">remove_if(node ** head, remove_fn rm)</code></p><p><code class="cpp plain">{</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">for</code> <code class="cpp plain">(node** curr = head; *curr; )</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">{</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">node * entry = *curr;</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">if</code> <code class="cpp plain">(rm(entry))</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">{</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">*curr = entry-&gt;next;</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp functions bold">free</code><code class="cpp plain">(entry);</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">}</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">else</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">curr = &amp;entry-&gt;next;</code></p><p><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">}</code></p><p><code class="cpp plain">}</code></p></div></td></tr></tbody></table></div></div><p>同上一段代碼有何改進呢？我們看到：<strong>不需要 prev 指針了，也不需要再去判斷是否為鏈表頭了，但是，<span>curr 變成了一個指向指針的指針</span></strong>。這正是這段程序的精妙之處。（注意，我所 highlight 的那三行代碼）</p><p>讓我們來人肉跑一下這個代碼，對於——</p><ul> <li><strong>刪除節點是表頭</strong>的情況，輸入參數中傳入 head 的二級指針，在 for 循環裡將其初始化 curr，然後 entry 就是 *head(*curr)，我們馬上刪除它，那麼第 8 行就等效於 *head = (*head)-&gt;next，就是刪除表頭的實現。</li> </ul> <ul> <li><strong>刪除節點不是表頭</strong>的情況，對於上面的代碼，我們可以看到——</li> </ul><p><strong>1）<strong>（第 12 行）</strong>如果不刪除當前結點 —— curr 保存的是當前結點 next 指針的地址</strong>。</p><p><strong>2）（第 5 行）&nbsp;entry 保存了 *curr&nbsp;<strong>——&nbsp;</strong>這意味著在下一次循環：entry 就是 prev-&gt;next 指針所指向的內存。</strong></p><p><strong></strong><strong>3）（第 8 行）刪除結點：*curr = entry-&gt;next; —— 於是：prev-&gt;next 指向了 entry -&gt; next;</strong></p><p>是不是很巧妙？我們可以只用一個二級指針來操作鏈表，對所有節點都一樣。</p><p>如果你對上面的代碼和描述理解上有困難的話，你可以看看下圖的示意：</p><p>（全文完）</p></div>

<img width="550" src="../img/linus_pointer_to_pointer.jpg"/>
</body>
</html>
